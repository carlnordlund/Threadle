To-do
=====




Export layer: export edgelists for chosen layers, for import/handling elsewhere.

Get summaries of attributes. Given a Nodeset and a variable, produce statistics on its values.

For int and float: min, max, mean median, stdev, Q1, Q3.



Possible extra functions:
Merge nodesets - combine different nodesets
Extract ego networks - get N-hop neighborhoods for sampled nodes
Layer operations - merge/intersect layers across domains
Sample N random nodes - so like getrandomnode
Stratified sampling? - by attribute value
Component analysis - nbr of components, subsets?
Attribute cross-tabulations?

Get node's layers?
Cross-layer queries: are two nodes connected in any domains? Like checkedge, getedge but for all layers (but could be iterated)
Layer-specific ego networks - already got, with getnodealters(), possible specify layername
Getalter attributes - get set of attributevalues of alters
Attribute summaries - on ego networks









Merge layers?

Get alter attributes

Symmetrize?

CLI command and Core methods for importing attributes from file? 'importattr()'? Given a file with attribute data, supplement existing Nodeset with this.
Pre-define attributes prior to import? Need to think a bit about this. Could also do this programmatically from R.




Done:

Fix getnodealters so that it is either for all layers, or for individual layer.
Removed filteroutnonexistingnodes - might not need it in Nodeset anymore.

Modified GetRandomAlter: check that it works

Implementing shortest path (for individual layers)









Modified generate() so that it now creates a random network in an existing binary layer in an existing network. Thus not creating a new network etc.


Modify how savefile and loadfile works? Idea for 'savefile()': make 'file' optional! Instead, always save to the IStructure.Filepath property by default, which is
set to something if 1) the structure has previously been loaded from file, or 2) if it has already been saved. I could thus do this:

nodes = loadfile(nodes.tsv, type = nodeset)
# the Nodeset is now loaded and stored to 'nodes' and the Filepath property is set to 'nodes.tsv'
# I could then modify this Nodeset - add/remove nodes, set attributes.
# If I then save it again, skipping the file argument:
savefile(nodes)
# ...the Nodeset will save it to its Filepath property, which is 'nodes.tsv'

# However, if the Filepath property was empty, e.g. if one has programmatically created it, then 'savefile(nodes)' would not work:
# that would give an error: no file specified. Then one must specify the filepath:
savefile(nodes, nodes.tsv)
# This would then save the Nodeset 'nodes' to this file, and ALSO set the Filepath property to 'nodes.tsv', so any additional
# saves can now skip the 'file' argument.

# However, one can still use the 'file' argument, even if the Filepath property is already set. Then this would save this Nodeset to this new
# 'file' - and it would also change the Filepath property of the Nodeset to this new 'file'. In essence, this is then like the typical 'Save as...'.

# What about loading and saving networks? Let's start with loading network:
net = loadfile(mynet.tsv, type = network)
# This would then load the 'mynet.tsv' file and create the Network structure, setting its Filepath to 'mynet.tsv'.
# As the NodesetFile: tag would be discovered, it would also try to load the Nodeset, i.e. setting it to 'net_nodes', i.e. '[base]_nodes',
# and setting the Nodeset Filepath to this path. If this fails, if there is no Nodeset found, this would then just produce a warning. Then
# nodes would be created on-the-fly instead. So 'loadfile([file], network)' would result in two stored structures: a Network and a Nodeset (either loaded or created on
# the fly)

# What about 'savefile(net)'?
# This would save the Network net to the file Filepath, i.e. given by its Filepath. It should also store the Nodeset! If the Nodeset has a Filepath, great: use that.
# If Nodeset doesn't have a filepath: ... Perhaps don't allow this? Force all savefile(net) to only work with Nodeset structures that are already saved?

# This means: if trying 'savefile(net)' and this network has a Nodeset that has no Filepath set, then refuse to save the network: state that the nodeset must be saved first.
# After the nodeset has been saved, it has a Filepath. Great! Then I can do 'savefile(net)', which would then save the Network AND its Nodeset (if it has been modified).

# This would remove the silly 'nodesetfile' argument in savefile, which is very weird.




FINISHED DOING the ones below
=============================
Added 'addaff(..)' CLI command and core methods for adding an affiliation, i.e. connecting a node id to a hyperedge.

Added 'removeaff(..)' CLI command and core methods for removing an affiliation, i.e. disconnecting a node id from a hyperedge.

Modified createnetwork() so that it MUST be provided with an already existing Nodeset!


Inventory: currently only returns a list. Perhaps better as json? And similar to info: either output as json for interop or list of lines for human readability.



Notes for 
threadleR stuff
===============

So: building an interop package for R!
In /threadleR/R/: threadle_client.R
Keep on adding functions and commenting - make sure they are up-to-date (new CLI command signatures)

Then to build package:
1. Navigate to inside /threadleR/ folder (i.e. where the stuff is)
2. library(roxygen2)
3. > roxygen2::roxygenise() # This will write NAMESPACE etc
4. Go to parent folder: /Threadle/Threadle.CLIconsole # i.e. the folder where /threadleR/ resides
5. > system("R CMD build threadleR") # This builds the tar.gz package
6. This package can now be installed: install.packages("threadleR_0.1.0.tar.gz", repos=NULL, type="source")
7. Then I can use it: library(threadleR)

Note that when starting: .start_threadle(), I really need to provide the path (assuming I am in \Threadle\Threadle.CLIconsole\)
path_to_exe <-"bin/Debug/net8.0/Threadle.CLIconsole.exe"
.start_threadle(path_to_exe)

Then I can later navigate etc and load networks etc.